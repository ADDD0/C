1.建立一个二叉树.
    (1)建立二叉树的数据结构,要求以二叉链表作为存储结构,可参考教材127页
    (2)读懂下面可创建二叉树的递归函数,例如:
        BiTree CreateBiTreeBitree(BiTree T) {
            ......
        }
        上边算法可参考教材131页算法6.4,注意录入的数据次序.

2.对建立的二叉树进行遍历.
    (1)写一个递归算法实现对二叉树的遍历,要求能输出结果,例如:
        int PreOrderTraverse(Bitree T) {  //先序遍历二叉树
            ......
        }
        上边算法可参考教材129页算法6.1.
    (2)编写主函数(main),调用函数CreateBiTree(T)来创建一个二叉树并遍历.
    (3)程序编制上的提示,仅供参考:
    #include "stdio.h"
    #include "string.h"
    #define  NULL  0

    typedef struct BiTNode {
        char data;  //注意结点类型
        struct  BiTNode *lchild, *rchild;
    } BiTNode, *BiTree;

    BiTree CreateBiTree(BiTree T) {  // 创建二叉树
        char ch; 

        getchar(ch);
        if (ch == '#')
            T = NULL;
        else {
            if (!(T = (BiTNode*) malloc(sizeof(BiTNode))))
                exit(0);
            T->data=ch;
            T->lchild = CreateBiTree(T->lchild);
            T->rchild = CreateBiTree(T->rchild);
        }
        return T;
    }

    int PreOrderTraverse(BiTree T) {
        //先序遍历二叉树，输出各结点的值
        ......
    }  //在完成先序遍历的基础上,可去实现中序和后序遍历算法
    注意:在实验报告要体现出先序遍历和中序遍历算法.

    int main() {
        BiTree T;

        T = CreateBiTree(T);  //创建二叉树
        printf(“The preorder of T is:\n”);
        PreOrderTraverse(T);  //先序遍历二叉树,输出T中各结点的值
        return 0;
    }
    注意:录入测试数据时一定要事先知道自己所要创建的二叉树.
    例如,输入的序列是:Ab##C##(回车),那么所创建的二叉树是什么样呢?参考教材131页.

3.用先序遍历方式输出二叉树中的大写字母,并将大写字母的个数存入全局变量count中.(选做)